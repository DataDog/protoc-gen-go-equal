// Code generated by protoc-gen-equal-go. DO NOT EDIT.
// source: internal/testprotos/test3/test.proto

package test3

import (
	other "github.com/melias122/protoc-gen-go-equal/internal/testprotos/other"
	proto "google.golang.org/protobuf/proto"
	math "math"
)

func (x *TestAllTypes_NestedMessage) Equal(y *TestAllTypes_NestedMessage) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if p, q := x.A, y.A; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !x.Corecursive.Equal(y.Corecursive) {
		return false
	}
	return true
}

func (x *TestAllTypes) Equal(y *TestAllTypes) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.SingularInt32 != y.SingularInt32 {
		return false
	}
	if x.SingularInt64 != y.SingularInt64 {
		return false
	}
	if x.SingularUint32 != y.SingularUint32 {
		return false
	}
	if x.SingularUint64 != y.SingularUint64 {
		return false
	}
	if x.SingularSint32 != y.SingularSint32 {
		return false
	}
	if x.SingularSint64 != y.SingularSint64 {
		return false
	}
	if x.SingularFixed32 != y.SingularFixed32 {
		return false
	}
	if x.SingularFixed64 != y.SingularFixed64 {
		return false
	}
	if x.SingularSfixed32 != y.SingularSfixed32 {
		return false
	}
	if x.SingularSfixed64 != y.SingularSfixed64 {
		return false
	}
	if (math.IsNaN(float64(x.SingularFloat)) && !math.IsNaN(float64(y.SingularFloat)) || !math.IsNaN(float64(x.SingularFloat)) && math.IsNaN(float64(y.SingularFloat))) || (!math.IsNaN(float64(x.SingularFloat)) && !math.IsNaN(float64(y.SingularFloat)) && x.SingularFloat != y.SingularFloat) {
		return false
	}
	if (math.IsNaN(float64(x.SingularDouble)) && !math.IsNaN(float64(y.SingularDouble)) || !math.IsNaN(float64(x.SingularDouble)) && math.IsNaN(float64(y.SingularDouble))) || (!math.IsNaN(float64(x.SingularDouble)) && !math.IsNaN(float64(y.SingularDouble)) && x.SingularDouble != y.SingularDouble) {
		return false
	}
	if x.SingularBool != y.SingularBool {
		return false
	}
	if x.SingularString != y.SingularString {
		return false
	}
	if string(x.SingularBytes) != string(y.SingularBytes) {
		return false
	}
	if !x.SingularNestedMessage.Equal(y.SingularNestedMessage) {
		return false
	}
	if !x.SingularForeignMessage.Equal(y.SingularForeignMessage) {
		return false
	}
	if !x.SingularImportMessage.Equal(y.SingularImportMessage) {
		return false
	}
	if x.SingularNestedEnum != y.SingularNestedEnum {
		return false
	}
	if x.SingularForeignEnum != y.SingularForeignEnum {
		return false
	}
	if x.SingularImportEnum != y.SingularImportEnum {
		return false
	}
	if p, q := x.OptionalInt32, y.OptionalInt32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.OptionalInt64, y.OptionalInt64; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.OptionalUint32, y.OptionalUint32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.OptionalUint64, y.OptionalUint64; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.OptionalSint32, y.OptionalSint32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.OptionalSint64, y.OptionalSint64; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.OptionalFixed32, y.OptionalFixed32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.OptionalFixed64, y.OptionalFixed64; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.OptionalSfixed32, y.OptionalSfixed32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.OptionalSfixed64, y.OptionalSfixed64; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.OptionalFloat, y.OptionalFloat; (p == nil && q != nil) || (p != nil && (q == nil || (math.IsNaN(float64(*p)) && !math.IsNaN(float64(*q)) || !math.IsNaN(float64(*p)) && math.IsNaN(float64(*q))) || (!math.IsNaN(float64(*p)) && !math.IsNaN(float64(*q)) && *p != *q))) {
		return false
	}
	if p, q := x.OptionalDouble, y.OptionalDouble; (p == nil && q != nil) || (p != nil && (q == nil || (math.IsNaN(float64(*p)) && !math.IsNaN(float64(*q)) || !math.IsNaN(float64(*p)) && math.IsNaN(float64(*q))) || (!math.IsNaN(float64(*p)) && !math.IsNaN(float64(*q)) && *p != *q))) {
		return false
	}
	if p, q := x.OptionalBool, y.OptionalBool; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.OptionalString, y.OptionalString; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.OptionalBytes, y.OptionalBytes; (p == nil && q != nil) || (p != nil && (q == nil || string(p) != string(q))) {
		return false
	}
	if !x.OptionalNestedMessage.Equal(y.OptionalNestedMessage) {
		return false
	}
	if !x.OptionalForeignMessage.Equal(y.OptionalForeignMessage) {
		return false
	}
	if !x.OptionalImportMessage.Equal(y.OptionalImportMessage) {
		return false
	}
	if p, q := x.OptionalNestedEnum, y.OptionalNestedEnum; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.OptionalForeignEnum, y.OptionalForeignEnum; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.OptionalImportEnum, y.OptionalImportEnum; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(x.RepeatedInt32) != len(y.RepeatedInt32) {
		return false
	}
	for i := 0; i < len(x.RepeatedInt32); i++ {
		if x.RepeatedInt32[i] != y.RepeatedInt32[i] {
			return false
		}
	}
	if len(x.RepeatedInt64) != len(y.RepeatedInt64) {
		return false
	}
	for i := 0; i < len(x.RepeatedInt64); i++ {
		if x.RepeatedInt64[i] != y.RepeatedInt64[i] {
			return false
		}
	}
	if len(x.RepeatedUint32) != len(y.RepeatedUint32) {
		return false
	}
	for i := 0; i < len(x.RepeatedUint32); i++ {
		if x.RepeatedUint32[i] != y.RepeatedUint32[i] {
			return false
		}
	}
	if len(x.RepeatedUint64) != len(y.RepeatedUint64) {
		return false
	}
	for i := 0; i < len(x.RepeatedUint64); i++ {
		if x.RepeatedUint64[i] != y.RepeatedUint64[i] {
			return false
		}
	}
	if len(x.RepeatedSint32) != len(y.RepeatedSint32) {
		return false
	}
	for i := 0; i < len(x.RepeatedSint32); i++ {
		if x.RepeatedSint32[i] != y.RepeatedSint32[i] {
			return false
		}
	}
	if len(x.RepeatedSint64) != len(y.RepeatedSint64) {
		return false
	}
	for i := 0; i < len(x.RepeatedSint64); i++ {
		if x.RepeatedSint64[i] != y.RepeatedSint64[i] {
			return false
		}
	}
	if len(x.RepeatedFixed32) != len(y.RepeatedFixed32) {
		return false
	}
	for i := 0; i < len(x.RepeatedFixed32); i++ {
		if x.RepeatedFixed32[i] != y.RepeatedFixed32[i] {
			return false
		}
	}
	if len(x.RepeatedFixed64) != len(y.RepeatedFixed64) {
		return false
	}
	for i := 0; i < len(x.RepeatedFixed64); i++ {
		if x.RepeatedFixed64[i] != y.RepeatedFixed64[i] {
			return false
		}
	}
	if len(x.RepeatedSfixed32) != len(y.RepeatedSfixed32) {
		return false
	}
	for i := 0; i < len(x.RepeatedSfixed32); i++ {
		if x.RepeatedSfixed32[i] != y.RepeatedSfixed32[i] {
			return false
		}
	}
	if len(x.RepeatedSfixed64) != len(y.RepeatedSfixed64) {
		return false
	}
	for i := 0; i < len(x.RepeatedSfixed64); i++ {
		if x.RepeatedSfixed64[i] != y.RepeatedSfixed64[i] {
			return false
		}
	}
	if len(x.RepeatedFloat) != len(y.RepeatedFloat) {
		return false
	}
	for i := 0; i < len(x.RepeatedFloat); i++ {
		if (math.IsNaN(float64(x.RepeatedFloat[i])) && !math.IsNaN(float64(y.RepeatedFloat[i])) || !math.IsNaN(float64(x.RepeatedFloat[i])) && math.IsNaN(float64(y.RepeatedFloat[i]))) || (!math.IsNaN(float64(x.RepeatedFloat[i])) && !math.IsNaN(float64(y.RepeatedFloat[i])) && x.RepeatedFloat[i] != y.RepeatedFloat[i]) {
			return false
		}
	}
	if len(x.RepeatedDouble) != len(y.RepeatedDouble) {
		return false
	}
	for i := 0; i < len(x.RepeatedDouble); i++ {
		if (math.IsNaN(float64(x.RepeatedDouble[i])) && !math.IsNaN(float64(y.RepeatedDouble[i])) || !math.IsNaN(float64(x.RepeatedDouble[i])) && math.IsNaN(float64(y.RepeatedDouble[i]))) || (!math.IsNaN(float64(x.RepeatedDouble[i])) && !math.IsNaN(float64(y.RepeatedDouble[i])) && x.RepeatedDouble[i] != y.RepeatedDouble[i]) {
			return false
		}
	}
	if len(x.RepeatedBool) != len(y.RepeatedBool) {
		return false
	}
	for i := 0; i < len(x.RepeatedBool); i++ {
		if x.RepeatedBool[i] != y.RepeatedBool[i] {
			return false
		}
	}
	if len(x.RepeatedString) != len(y.RepeatedString) {
		return false
	}
	for i := 0; i < len(x.RepeatedString); i++ {
		if x.RepeatedString[i] != y.RepeatedString[i] {
			return false
		}
	}
	if len(x.RepeatedBytes) != len(y.RepeatedBytes) {
		return false
	}
	for i := 0; i < len(x.RepeatedBytes); i++ {
		if string(x.RepeatedBytes[i]) != string(y.RepeatedBytes[i]) {
			return false
		}
	}
	if len(x.RepeatedNestedMessage) != len(y.RepeatedNestedMessage) {
		return false
	}
	for i := 0; i < len(x.RepeatedNestedMessage); i++ {
		if !x.RepeatedNestedMessage[i].Equal(y.RepeatedNestedMessage[i]) {
			return false
		}
	}
	if len(x.RepeatedForeignMessage) != len(y.RepeatedForeignMessage) {
		return false
	}
	for i := 0; i < len(x.RepeatedForeignMessage); i++ {
		if !x.RepeatedForeignMessage[i].Equal(y.RepeatedForeignMessage[i]) {
			return false
		}
	}
	if len(x.RepeatedImportmessage) != len(y.RepeatedImportmessage) {
		return false
	}
	for i := 0; i < len(x.RepeatedImportmessage); i++ {
		if !x.RepeatedImportmessage[i].Equal(y.RepeatedImportmessage[i]) {
			return false
		}
	}
	if len(x.RepeatedNestedEnum) != len(y.RepeatedNestedEnum) {
		return false
	}
	for i := 0; i < len(x.RepeatedNestedEnum); i++ {
		if x.RepeatedNestedEnum[i] != y.RepeatedNestedEnum[i] {
			return false
		}
	}
	if len(x.RepeatedForeignEnum) != len(y.RepeatedForeignEnum) {
		return false
	}
	for i := 0; i < len(x.RepeatedForeignEnum); i++ {
		if x.RepeatedForeignEnum[i] != y.RepeatedForeignEnum[i] {
			return false
		}
	}
	if len(x.RepeatedImportenum) != len(y.RepeatedImportenum) {
		return false
	}
	for i := 0; i < len(x.RepeatedImportenum); i++ {
		if x.RepeatedImportenum[i] != y.RepeatedImportenum[i] {
			return false
		}
	}
	if len(x.MapInt32Int32) != len(y.MapInt32Int32) {
		return false
	}
	for k := range x.MapInt32Int32 {
		_, ok := y.MapInt32Int32[k]
		if !ok {
			return false
		}
		if x.MapInt32Int32[k] != y.MapInt32Int32[k] {
			return false
		}
	}
	if len(x.MapInt64Int64) != len(y.MapInt64Int64) {
		return false
	}
	for k := range x.MapInt64Int64 {
		_, ok := y.MapInt64Int64[k]
		if !ok {
			return false
		}
		if x.MapInt64Int64[k] != y.MapInt64Int64[k] {
			return false
		}
	}
	if len(x.MapUint32Uint32) != len(y.MapUint32Uint32) {
		return false
	}
	for k := range x.MapUint32Uint32 {
		_, ok := y.MapUint32Uint32[k]
		if !ok {
			return false
		}
		if x.MapUint32Uint32[k] != y.MapUint32Uint32[k] {
			return false
		}
	}
	if len(x.MapUint64Uint64) != len(y.MapUint64Uint64) {
		return false
	}
	for k := range x.MapUint64Uint64 {
		_, ok := y.MapUint64Uint64[k]
		if !ok {
			return false
		}
		if x.MapUint64Uint64[k] != y.MapUint64Uint64[k] {
			return false
		}
	}
	if len(x.MapSint32Sint32) != len(y.MapSint32Sint32) {
		return false
	}
	for k := range x.MapSint32Sint32 {
		_, ok := y.MapSint32Sint32[k]
		if !ok {
			return false
		}
		if x.MapSint32Sint32[k] != y.MapSint32Sint32[k] {
			return false
		}
	}
	if len(x.MapSint64Sint64) != len(y.MapSint64Sint64) {
		return false
	}
	for k := range x.MapSint64Sint64 {
		_, ok := y.MapSint64Sint64[k]
		if !ok {
			return false
		}
		if x.MapSint64Sint64[k] != y.MapSint64Sint64[k] {
			return false
		}
	}
	if len(x.MapFixed32Fixed32) != len(y.MapFixed32Fixed32) {
		return false
	}
	for k := range x.MapFixed32Fixed32 {
		_, ok := y.MapFixed32Fixed32[k]
		if !ok {
			return false
		}
		if x.MapFixed32Fixed32[k] != y.MapFixed32Fixed32[k] {
			return false
		}
	}
	if len(x.MapFixed64Fixed64) != len(y.MapFixed64Fixed64) {
		return false
	}
	for k := range x.MapFixed64Fixed64 {
		_, ok := y.MapFixed64Fixed64[k]
		if !ok {
			return false
		}
		if x.MapFixed64Fixed64[k] != y.MapFixed64Fixed64[k] {
			return false
		}
	}
	if len(x.MapSfixed32Sfixed32) != len(y.MapSfixed32Sfixed32) {
		return false
	}
	for k := range x.MapSfixed32Sfixed32 {
		_, ok := y.MapSfixed32Sfixed32[k]
		if !ok {
			return false
		}
		if x.MapSfixed32Sfixed32[k] != y.MapSfixed32Sfixed32[k] {
			return false
		}
	}
	if len(x.MapSfixed64Sfixed64) != len(y.MapSfixed64Sfixed64) {
		return false
	}
	for k := range x.MapSfixed64Sfixed64 {
		_, ok := y.MapSfixed64Sfixed64[k]
		if !ok {
			return false
		}
		if x.MapSfixed64Sfixed64[k] != y.MapSfixed64Sfixed64[k] {
			return false
		}
	}
	if len(x.MapInt32Float) != len(y.MapInt32Float) {
		return false
	}
	for k := range x.MapInt32Float {
		_, ok := y.MapInt32Float[k]
		if !ok {
			return false
		}
		if (math.IsNaN(float64(x.MapInt32Float[k])) && !math.IsNaN(float64(y.MapInt32Float[k])) || !math.IsNaN(float64(x.MapInt32Float[k])) && math.IsNaN(float64(y.MapInt32Float[k]))) || (!math.IsNaN(float64(x.MapInt32Float[k])) && !math.IsNaN(float64(y.MapInt32Float[k])) && x.MapInt32Float[k] != y.MapInt32Float[k]) {
			return false
		}
	}
	if len(x.MapInt32Double) != len(y.MapInt32Double) {
		return false
	}
	for k := range x.MapInt32Double {
		_, ok := y.MapInt32Double[k]
		if !ok {
			return false
		}
		if (math.IsNaN(float64(x.MapInt32Double[k])) && !math.IsNaN(float64(y.MapInt32Double[k])) || !math.IsNaN(float64(x.MapInt32Double[k])) && math.IsNaN(float64(y.MapInt32Double[k]))) || (!math.IsNaN(float64(x.MapInt32Double[k])) && !math.IsNaN(float64(y.MapInt32Double[k])) && x.MapInt32Double[k] != y.MapInt32Double[k]) {
			return false
		}
	}
	if len(x.MapBoolBool) != len(y.MapBoolBool) {
		return false
	}
	for k := range x.MapBoolBool {
		_, ok := y.MapBoolBool[k]
		if !ok {
			return false
		}
		if x.MapBoolBool[k] != y.MapBoolBool[k] {
			return false
		}
	}
	if len(x.MapStringString) != len(y.MapStringString) {
		return false
	}
	for k := range x.MapStringString {
		_, ok := y.MapStringString[k]
		if !ok {
			return false
		}
		if x.MapStringString[k] != y.MapStringString[k] {
			return false
		}
	}
	if len(x.MapStringBytes) != len(y.MapStringBytes) {
		return false
	}
	for k := range x.MapStringBytes {
		_, ok := y.MapStringBytes[k]
		if !ok {
			return false
		}
		if string(x.MapStringBytes[k]) != string(y.MapStringBytes[k]) {
			return false
		}
	}
	if len(x.MapStringNestedMessage) != len(y.MapStringNestedMessage) {
		return false
	}
	for k := range x.MapStringNestedMessage {
		_, ok := y.MapStringNestedMessage[k]
		if !ok {
			return false
		}
		if !x.MapStringNestedMessage[k].Equal(y.MapStringNestedMessage[k]) {
			return false
		}
	}
	if len(x.MapStringNestedEnum) != len(y.MapStringNestedEnum) {
		return false
	}
	for k := range x.MapStringNestedEnum {
		_, ok := y.MapStringNestedEnum[k]
		if !ok {
			return false
		}
		if x.MapStringNestedEnum[k] != y.MapStringNestedEnum[k] {
			return false
		}
	}
	if x.GetOneofUint32() != y.GetOneofUint32() {
		return false
	}
	if !x.GetOneofNestedMessage().Equal(y.GetOneofNestedMessage()) {
		return false
	}
	if x.GetOneofString() != y.GetOneofString() {
		return false
	}
	if string(x.GetOneofBytes()) != string(y.GetOneofBytes()) {
		return false
	}
	if x.GetOneofBool() != y.GetOneofBool() {
		return false
	}
	if x.GetOneofUint64() != y.GetOneofUint64() {
		return false
	}
	if (math.IsNaN(float64(x.GetOneofFloat())) && !math.IsNaN(float64(y.GetOneofFloat())) || !math.IsNaN(float64(x.GetOneofFloat())) && math.IsNaN(float64(y.GetOneofFloat()))) || (!math.IsNaN(float64(x.GetOneofFloat())) && !math.IsNaN(float64(y.GetOneofFloat())) && x.GetOneofFloat() != y.GetOneofFloat()) {
		return false
	}
	if (math.IsNaN(float64(x.GetOneofDouble())) && !math.IsNaN(float64(y.GetOneofDouble())) || !math.IsNaN(float64(x.GetOneofDouble())) && math.IsNaN(float64(y.GetOneofDouble()))) || (!math.IsNaN(float64(x.GetOneofDouble())) && !math.IsNaN(float64(y.GetOneofDouble())) && x.GetOneofDouble() != y.GetOneofDouble()) {
		return false
	}
	if x.GetOneofEnum() != y.GetOneofEnum() {
		return false
	}
	if p, q := x.GetOneofWrappersStringValue(), y.GetOneofWrappersStringValue(); (p == nil && q != nil) || (p != nil && (q == nil || p.Value != q.Value)) {
		return false
	}
	if p, q := x.Any, y.Any; (p == nil && q != nil) || (p != nil && (q == nil || p.TypeUrl != q.TypeUrl || string(p.Value) != string(q.Value))) {
		return false
	}
	if p, q := x.Duration, y.Duration; (p == nil && q != nil) || (p != nil && (q == nil || p.Seconds != q.Seconds || p.Nanos != q.Nanos)) {
		return false
	}
	if p, q := x.Empty, y.Empty; (p == nil && q != nil) || (p != nil && q == nil) {
		return false
	}
	if p, q := x.Timestamp, y.Timestamp; (p == nil && q != nil) || (p != nil && (q == nil || p.Seconds != q.Seconds || p.Nanos != q.Nanos)) {
		return false
	}
	if p, q := x.WrappersBoolValue, y.WrappersBoolValue; (p == nil && q != nil) || (p != nil && (q == nil || p.Value != q.Value)) {
		return false
	}
	if p, q := x.WrappersBytesValue, y.WrappersBytesValue; (p == nil && q != nil) || (p != nil && (q == nil || string(p.Value) != string(q.Value))) {
		return false
	}
	if p, q := x.WrappersDoubleValue, y.WrappersDoubleValue; (p == nil && q != nil) || (p != nil && (q == nil || p.Value != q.Value)) {
		return false
	}
	if p, q := x.WrappersFloatValue, y.WrappersFloatValue; (p == nil && q != nil) || (p != nil && (q == nil || p.Value != q.Value)) {
		return false
	}
	if p, q := x.WrappersInt32Value, y.WrappersInt32Value; (p == nil && q != nil) || (p != nil && (q == nil || p.Value != q.Value)) {
		return false
	}
	if p, q := x.WrappersInt64Value, y.WrappersInt64Value; (p == nil && q != nil) || (p != nil && (q == nil || p.Value != q.Value)) {
		return false
	}
	if p, q := x.WrappersStringValue, y.WrappersStringValue; (p == nil && q != nil) || (p != nil && (q == nil || p.Value != q.Value)) {
		return false
	}
	if p, q := x.WrappersUint32Value, y.WrappersUint32Value; (p == nil && q != nil) || (p != nil && (q == nil || p.Value != q.Value)) {
		return false
	}
	if p, q := x.WrappersUint64Value, y.WrappersUint64Value; (p == nil && q != nil) || (p != nil && (q == nil || p.Value != q.Value)) {
		return false
	}
	if x.Enums3 != y.Enums3 {
		return false
	}
	if equal, ok := interface{}(x.OtherMessage).(interface {
		Equal(*other.OtherMessage) bool
	}); !ok || !equal.Equal(y.OtherMessage) {
		return false
	} else if !proto.Equal(x.OtherMessage, y.OtherMessage) {
		return false
	}
	return true
}

func (x *ForeignMessage) Equal(y *ForeignMessage) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.C != y.C {
		return false
	}
	if x.D != y.D {
		return false
	}
	return true
}
